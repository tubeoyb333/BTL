import tkinter as tk
from tkinter import ttk, simpledialog, messagebox
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import sympy as sp
import numpy as np

class MathExpression:
    def __init__(self, expression_str):
        self.expression_str = expression_str
        self.x = sp.symbols('x')

        try:
            self.expression = sp.sympify(expression_str)
        except Exception as e:
            raise ValueError(f"Lỗi: {str(e)}")

class MathAppGUI:
    def __init__(self, master):
        self.master = master
        self.master.title("Math Functions GUI")

        self.create_widgets()

    def create_widgets(self):
        ttk.Label(self.master, text="Nhập hàm số (sử dụng 'x' là biến):").grid(row=0, column=0, pady=10, padx=10, sticky=tk.W)

        self.entry_function = ttk.Entry(self.master, width=50)
        self.entry_function.grid(row=0, column=1, pady=10, padx=10, columnspan=2)

        functions = {
            "Tính Đạo Hàm": self.calculate_derivative,
            "Vẽ Đồ Thị": self.plot_graph,
            "Tính Nguyên Hàm": self.calculate_integral,
            "Giải Phương Trình": self.solve_equation,
            "Tính Diện Tích": self.calculate_area,
            "Tìm Điểm Cực Trị": self.find_extreme_points,
            "Tính Diện Tích Hai Hàm": self.calculate_area_between_functions,
            "Kiểm Tra Tính Liên Tục": self.check_continuity
        }

        row_index = 2
        for text, command in functions.items():
            ttk.Button(self.master, text=text, command=command).grid(row=row_index, column=0, pady=5, padx=5)
            row_index += 1

        self.result_label = ttk.Label(self.master, text="", wraplength=400)
        self.result_label.grid(row=row_index, column=0, pady=10, padx=10, columnspan=3, rowspan=2, sticky=tk.W + tk.E)

        self.math_expression = None

    def get_expression(self):
        expression_str = self.entry_function.get()
        try:
            self.math_expression = MathExpression(expression_str)
        except ValueError as ve:
            self.show_error(str(ve))
            return None
        return self.math_expression.x, self.math_expression.expression

    def calculate_derivative(self):
        expression_info = self.get_expression()
        if expression_info:
            x, expression = expression_info
            try:
                n = self.get_single_value("Bậc của đạo hàm cần tính:")
                derivate = sp.diff(expression, x, n)
                self.show_result(f"Đạo hàm bậc {n}: {derivate}")
            except ValueError:
                self.show_error("Vui lòng nhập một số nguyên làm bậc của đạo hàm.")

    def plot_graph(self):
        expression_info = self.get_expression()
        if expression_info:
            x, expression = expression_info
            x_vals = np.linspace(-10, 10, 1000)
            y_vals = [expression.subs(x, val) for val in x_vals]

            figure = Figure(figsize=(5, 4), dpi=100)
            plot = figure.add_subplot(1, 1, 1)
            plot.plot(x_vals, y_vals)
            plot.set_title("Đồ thị hàm số")
            plot.set_xlabel("x")
            plot.set_ylabel("f(x)")

            canvas = FigureCanvasTkAgg(figure, master=self.master)
            canvas.draw()
            canvas.get_tk_widget().grid(row=1, column=1, rowspan=8, pady=5, padx=5, columnspan=2)

    def calculate_integral(self):
        x, expression = self.get_expression()
        integral = sp.integrate(expression, x)
        self.show_result(f"Nguyên hàm của hàm số: {integral}")

    def solve_equation(self):
        x, expression = self.get_expression()
        solutions = sp.solve(expression, x)
        self.show_result(f"Nghiệm của phương trình: {solutions}")

    def calculate_area(self):
        x, expression = self.get_expression()
        range_start, range_end = self.get_range_values()
        area = sp.integrate(expression, (x, range_start, range_end))
        self.show_result(f"Diện tích hình phẳng giới hạn bởi hàm số: {area}")

    def find_extreme_points(self):
        x, expression = self.get_expression()
        critical_points = sp.solve(sp.diff(expression, x), x)
        extreme_points = []

        for point in critical_points:
            second_derivative = sp.diff(expression, x, 2).subs(x, point)

            if second_derivative > 0:
                extreme_points.append({"point": point, "type": "Cực tiểu"})
            elif second_derivative < 0:
                extreme_points.append({"point": point, "type": "Cực đại"})

        self.show_result("Các điểm cực trị của hàm số:")
        for point in extreme_points:
            self.show_result(f"{point['type']} tại x = {point['point']}")

    def calculate_area_between_functions(self):
        x, expression_1 = self.get_expression()
        x_2, expression_2 = self.get_second_expression()
        range_start, range_end = self.get_range_values()

        intersections = sp.solve(sp.Eq(expression_1, expression_2), x)

        if len(intersections) != 2:
            self.show_error("Hai hàm số không giao nhau đúng hai điểm.")
            return

        intersections.sort()
        area = sp.integrate(expression_1 - expression_2, (x, intersections[0], intersections[1]))
        self.show_result(f"Diện tích giới hạn bởi hai hàm số: {area}")

    def check_continuity(self):
        x, expression = self.get_expression()
        a = self.get_single_value("Nhập giá trị cần kiểm tra tính liên tục tại x = a:")
        limit_left = sp.limit(expression, x, a, dir='-')
        limit_right = sp.limit(expression, x, a, dir='+')

        if limit_left == limit_right:
            self.show_result(f"Hàm số liên tục tại x = {a}")
        else:
            self.show_result(f"Hàm số không liên tục tại x = {a}")

    def show_result(self, message):
        self.result_label.config(text=message)

    def show_error(self, message):
        messagebox.showerror("Lỗi", message)

    def get_range_values(self):
        range_values = self.get_values("Nhập khoảng giá trị x (bắt đầu và kết thúc, cách nhau bởi dấu cách):")
        return float(range_values[0]), float(range_values[1])

    def get_second_expression(self):
        x, expression_2 = self.get_expression("Nhập hàm số thứ hai (sử dụng 'x' là biến):")
        return x, expression_2

    def get_values(self, message):
        return self.get_input(message).split()

    def get_single_value(self, message):
        return self.get_input(message)

    def get_input(self, message):
        return simpledialog.askstring("Input", message)

def main():
    root = tk.Tk()
    app = MathAppGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
